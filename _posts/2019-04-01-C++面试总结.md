---
layout: post
title: C++面试总结
date: 2019-04-01
categories: C++
tags: 面试
---


# C++面试总结
## 声明与定义的区别。
* 从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义，例如：`int a` 它既是声明，同时又是定义。然而对于 `extern int a` 来讲它只是声明不是定义。
* 1、定义，即定义性声明，是需要建立存储空间的。例如：`int a` 在声明的时候就已经建立了存储空间。
* 2、声明，狭义上指引用性声明，是不需要建立存储空间的。 例如：`extern int a` 其中变量a是在别的文件中定义的。

##  extern 和 static 的区别，什么情况用前者什么情况用后者
* 用`static`来声明一个变量的作用有二：
	* (1)对于局部变量用`static`声明，则是为该变量分配的空间在整个程序的执行期内都始终存在。
	* (2)外部变量用`static`来声明，则该变量的作用只限于本文件模块。
	* 在C++中`static`还具有其它功能，如果在C++中对类中的某个函数用`static`进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行`static`修饰，表示该变量为类以及其所有的对象所有，全局变量，即使不存在任何一个对象，但它都存在。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。静态成员函数要在类外面再单独声明，对于静态成员函数，只能访问静态成员函数和静态成员变量，不能访问非静态成员函数或者变量。`sizeof`不会计算静态成员变量

* `extern`关键字

   * 在C语言中，修饰符`extern`用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

   	```
   	file1.c
   	int a=1;
   	
   	file2.c
   	#include<stdio.h>
   	extern int a;
   	int main(void) {
   		printf("%d\",a);
   		return 0;
   	}
   ```
   * 在上面的例子中可以看出，在file2中如果想调用file1中的变量a，只须用`extern`进行声明即可调用a，这就是`extern`的作用。在这里要注意`extern`声明的位置对其作用域也有关系，如果是在`main`函数中进行声明的，则只能在`main`函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用`#include`包含进来即可，**为啥要用extern？**因为用extern会加速程序的编译过程，这样能节省时间。

   * 在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题


## x=x+1,x+=1,x++哪个效率高
* `x=x+1`：在执行过程中先取等号右边`x`的地址，计算`x+1`，然后取等号左边`x`的地址，最后将等号右边的值传给等号左边。

* `x+=1`：执行过程中先取等号左边x的地址，然后计算`x+1`，最后将得到的值给`x`，因为之前等号左边`x`的地址已经读出来了，所以这里就少了一次读取地址的操作，效率高于x=x+1

* `x++`：先读取`x`的地址，然后对`x`自增1，效率是三个里面最高的

## const 和 #define 的优缺点
* const : 具有变量的基本属性，有类型，占存储空间，只是其值不允许再改变
* `#define` : 符号常量、宏定义
* 区别
	* （1）就起作用的阶段而言： `#define`是在编译的预处理阶段起作用，而`const`是在编译、运行的时候起作用。
	* （2）就起作用的方式而言： `#define`只是简单的字符串替换，没有类型检查。而`const`有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
	* （3）就存储方式而言：`#define`只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；`const`定义的只读变量在程序运行过程中只有一份备份。
	* （4）从代码调试的方便程度而言： `const`常量可以进行调试的，`define`是不能进行调试的，因为在预编译阶段就已经替换掉了。

## strcpy和memcpy的区别，现场要求手撕代码
* `strcpy` : `char* strcpy(char* dest, const char* src);`拷贝**字符串**，遇到'\0'时结束拷贝。
* `memcpy` : `void *memcpy( void *dest, const void *src, size_t count );`用来做内存拷贝，可以拷贝任何数据类型的对象并指定拷贝数据的长度：`char a[100],b[50]; memcpy(b, a, sizeof(b));`
* 区别:
	* 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
	* 复制的方法不同。strcpy不需要指定长度，它遇到字符串结束符"\0"便结束。memcpy则是根据其第3个参数决定复制的长度。
	* 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。

## strcpy 有什么危险？
* `strcpy` 是依据 `\0` 作为结束判断的，如果 `dest` 的空间不够，则会引起 `buffer overflow`。
* 安全版本：`char *strncpy(char * dest, const char * src,  size_t n)`  但 `strncpy` 其行为是很诡异的（不符合我们的通常习惯）。标准规定 `n` 并不是 `sizeof(s1)`，而是要复制的 char 的个数。一个最常见的问题，就是 `strncpy` 并不帮你保证 `\0`.
* **误解一**：如果`src` 长度小于 `n`, 那么`strncpy` 和 `strcpy` 效果一样？错，事实上，`strncpy` 还会把 `dest` 剩下的部分全部置为 `\0`！
* **误解二**：如果`src` 长度大于等于 `n`, 那么 `strncpy` 会拷贝 `n – 1` 各字符到 `dest`, 然后补 `\0`？如果待拷贝字符串长度大于了 `n`, 那么 dest 是不会有结尾字符 `\0` 的。

## new 和 malloc 的区别
* 属性: `new/delete`是C++操作符(关键字)，需要编译器支持。`malloc/free`是库函数，需要头文件`<stdlib.h>`支持。
* 参数: 使用`new`操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而`malloc`则需要显式地指出所需内存的尺寸。
* 返回类型: `new`操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故`new`是符合类型安全性的操作符。而`malloc`内存分配成功则是返回`void *` ，需要通过强制类型转换将`void*`指针转换成我们需要的类型。
* 分配失败: `new`内存分配失败时，会抛出`bac_alloc`异常。`malloc`分配内存失败时返回`NULL`。
* 自定义类型: `new`会先调用`operator new`函数，申请足够的内存（通常底层使用`malloc`实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。`delete`先调用析构函数，然后调用`operator delete`函数释放内存（通常底层使用`free`实现）`malloc/free`是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
* 重载: C++允许重载`new/delete`操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
* 内存区域: new操作符从自由存储区（free store）上为对象动态分配内存空间，而`malloc`函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

## C++的内存分配
* 1、栈区(stack)：又编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。
* 2、堆区(heap)：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。
* 3、全局区(static)：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。
* 4、文字常量区：常量字符串就是放在这里，程序结束后由系统释放。
* 5、程序代码区：存放函数体的二进制代码。

## 存储类别
* 局部变量
	* 动态局部变量（auto）
	* 寄存器变量（register）
	* 静态局部变量（static 离开函数值仍然保留，但是只能被此函数使用）
* 全局变量
	* 静态全局变量（限本文本使用）
	* 外部变量（定义只能有一次，且在函数外，但可以有多次声明（extern））  


## C/C++程序编译过程详解
![](/img/CompilationProcess.png)

* 编译： 编译是读取源程序（字符流），对之进行**词法**和**语法**的分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个主要阶段：
	* 编译预处理： 读取c源程序，对其中的伪指令（以`#`开头的指令）和特殊符号进行处理。生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。
	* 编译优化阶段: 优化一部分是对中间代码的优化, 要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除, 这种优化不依赖于具体的计算机; 另一种优化则主要针对目标代码的生成而进行的, 同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放有关变量的值，以减少对于内存的访问次数
* 汇编: 汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成。通常一个目标文件中至少有两个段：
	* 代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
	* 数据段：主要存放程序中要用到的各种**全局变量或静态的**数据。一般数据段都是可读，可写，可执行的。
	* UNIX环境下主要有三种类型的目标文件：
		* 可重定位文件: 其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。
		* 共享的目标文件: 这种文件存放了适合于在两种上下文里链接的代码和数据。第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。
		* 可执行文件: 它包含了一个可以被操作系统创建一个进程来执行之的文件。
	* 汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。
* 链接过程: 由**汇编程序生成的目标文件**并不能立即就被执行，其中可能还有许多没有解决的问题。链接程序的主要工作就是将有关的目标文件彼此相连接，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：
	* 静态链接: 在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。
	* 动态链接: 在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。
	* 对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

## 构造函数和析构函数可不可以为虚函数，为什么？
* 构造函数不能为虚函数？
	* C++对象在三个地方构建：（1）函数堆栈；（2）自由存储区，或称之为堆；（3）静态存储区。无论在那里构建，其过程都是两步：首先，分配一块内存；其次，调用构造函数。好，问题来了，如果构造函数是虚函数，那么就需要通过vtable 来调用，但此时面对一块 raw memeory，到哪里去找 vtable 呢？毕竟，vtable 是在构造函数中才初始化的啊，而不是在其之前。因此构造函数不能为虚函数。

* 析构函数可以使用虚函数
	* 对象已经创建，虚表指针存放析构函数的地址，基类与派生类都含有析构虚函数，创建基类与子类对象，都含有各类的虚表指针，当写通用函数时，运行根据传入对象的类型确定析构函数的地址，然后调用该析构函数。 但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。

* 虚析构函数：是针对通过基类的指针删除派生类对象时只调用基类的析构函数的这个问题的，用了虚析构函数，就可以在通过基类指针删除一个派生类对象时先调用派生类的析构函数，再调用基类的析构函数

* 纯虚函数：没有函数体的虚函数；包含这个纯虚函数的类是抽象类，只能作为基类，不能创建抽象类的对象；抽象类的指针和引用可以指向由抽象类派生出的类的对象

## 死锁的条件
* 循环等待
* 占有并等待
* 非抢占
* 互斥

## 如何限制一个类对象只能在堆（栈）上分配空间
* 只能建立在堆上，将析构函数设为私有，类对象就无法建立在栈上了（不能再用A a)这种方式建立对象了，只能new
* 只能建立在栈上，只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。

## 拷贝构造函数如果用值传递会有什么影响？
传值的话会拷贝构造函数的无限递归，最终导致栈溢出。
如果拷贝函数是这个样子
`S(const S st){this->a=st.a;}//拷贝构造函数`
当给S2初始化的时候调用了s2的拷贝构造函数，由于是值传递，系统会给形参st重新申请一段空间，然后调用自身的拷贝构造函数把s1的数据成员的值传给st。当调用自身的拷贝构造函数的时候又因为是值传递，也就是说，只要调用拷贝构造函数，就会重新申请一段空间，只要重新申请一段空间，就会调用拷贝构造函数，这样一直下去就形成了一个死循环。
所以拷贝构造函数一定不能是值传递。

## struct的字节对齐
* 规则一.： 每个成员变量在其结构体内的偏移量都是成员变量类型的大小的倍数。
* 规则二： 如果有嵌套结构体，那么内嵌结构体的第一个成员变量在外结构体中的偏移量，是内嵌结构体中那个数据类型大小最大的成员变量的倍数。
* 规则三： 整个结构体的大小要是这个结构体内数据类型大小最大的成员变量的倍数。如果有内嵌结构体，那么取内嵌结构体中数据类型大小最大的成员变量作为计算外结构体整体大小的依据。

* 1.test1   空结构体

```
typedef struct node {
     
}S;
```
则sizeof(S)=1;或sizeof(S)=0;在C++中占1字节，而在C中占0字节。

* 2.test2

```
typedef struct node1 {
    int a;
    char b;
    short c;
}S1;
```
则sizeof(S1)=8。这是因为结构体node1中最长的数据类型是int，占4个字节，因此以4字节对齐，则该结构体在内存中存放方式为

|--------int--------|   4字节

|char|----|--short-|   4字节

总共占8字节

* 3.test3


```
typedef struct node2 {
    char a;
    int b;
    short c;
}S2;
```
则siezof(S3)=12.最长数据类型为int，占4个字节。因此以4字节对齐，其在内存空间存放方式如下:

|char|----|----|----|  4字节   
|--------int--------|  4字节   
|--short--|----|----|  4字节

总共占12个字节

* 4.test4  含有静态数据成员 

```
typedef struct node3 {
    int a;
    short b;
    static int c;
}S3;
```
则sizeof(S3)=8.这里结构体中包含静态数据成员，而静态数据成员的存放位置与结构体实例的存储地址无关(注意只有在C++中结构体中才能含有静态数据成员，而C中结构体中是不允许含有静态数据成员的)。其在内存中存储方式如下：

|--------int--------|   4字节   
|--short-|----|----|    4字节   

而变量c是单独存放在静态数据区的，因此用siezof计算其大小时没有将c所占的空间计算进来。

* 5.test5  结构体中含有结构体

```
typedef struct node4 {
    bool a;
    S1 s1;
    short b;
}S4;
```
则sizeof(S4)=16。是因为s1占8字节，而s1中最长数据类型为int，占4个字节，bool类型1个字节，short占2字节，因此以4字节对齐，则存储方式为

|-------bool--------|  4字节   
|-------s1----------|  4字节    
|-------s1----------|  4字节    
|-------short-------|  4字节   

* 6.test6

```
typedef struct node5 {
    bool a;
    S1 s1;
    double b;
    int c;
}S5;
```
则sizeof(S5)=32。是因为s1占8字节，而s1中最长数据类型为int，占4字节，而double占8字节，因此以8字节对齐，则存放方式为：

|--------bool--------|    8字节

|---------s1---------|    8字节

|--------double------|    8字节

|----int---|---------|     8字节 

* 7.test7    
若在程序中使用了`#pragma pack(n)`命令强制以n字节对齐时，默认情况下n为8.则比较n和结构体中最长数据类型所占的字节大小，取两者中小的一个作为对齐标准。若需取消强制对齐方式，则可用命令`#pragma pack()`

如果在程序开头使用命令`#pragma pack(4)`，对于下面的结构体

```
typedef struct node5{
    bool a;
    S1 s1;
    double b;
    int c;
}S5;
```
则sizeof(S5)=24.因为强制以4字节对齐，而S5中最长数据类型为double，占8字节，因此以4字节对齐。在内存中存放方式为：

  |-----------a--------|   4字节

  |--------s1----------|   4字节

  |--------s1----------|   4字节

  |--------b-----------|   4字节

  |--------b-----------|   4字节

  |---------c----------|    4字节
 
## 智能指针，共享指针
* 智能指针是RAII（Resource Acquisition is initialization）用来动态的分配内存。它提供了普通指针的所有接口外加少数异常处理。在构造阶段，它将分配内存，而在非其作用域内将自动释放所占有的内存。 
* shared_ptr 主要的功能是，管理动态创建的对象的销毁。它的基本原理就是记录对象被引用的次数，当引用次数为 0 的时候，也就是最后一个指向某对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。共享指针对象重载了 operator* 和 operator-> , 所以你可以像通常的指针一样使用它。

## 派生类将基类中除去构造函数和析构函数的其他方法继承了过来，那么对于派生类对象中自己的成员变量和来自基类的成员变量，它们的构造方式是怎样的呢？
*  1.执行基类的构造函数；
*  2.初始化派生类的成员变量，由于成员是一个类类型，所以会调用成员的构造函数
*  3.执行派生类的构造函数。
析构：与构造顺序相反

* 1.先调用基类构造函数，构造基类部分成员变量，如果有成员对象再调用成员对象的构造函数，初始化派生类中的成员对象，再调用派生类构造函数，构造派生类部分的成员变量。
* 2.基类部分成员的初始化方式在派生类构造函数的初始化列表中指定。
* 3.若基类中还有成员对象，则先调用成员对象的构造函数，再调用基类构造函数，最后是派生类构造函数。析构顺序和构造顺序相反。

## 继承和多态区别与联系？
* 继承，能够增强类的复用
* 多态，能够增强程序的可扩充性，编译时不确定调用的到底是基类还是派生类的函数，在运行时才确定，动态联编
	* 通过基类的指针调用基类和派生类的同名虚函数（派生类指针可以赋值给基类指针）
		* 若该指针指向一个基类的对象，那么被调用的是基类的虚函数
		* 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数
	* 通过基类引用调用基类和派生类的同名虚函数（派生类的对象可以赋值给基类引用）
		* 若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数
		* 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数
* 虚函数表：每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针，虚函数表中列出了该类的虚函数地址

## Public继承兼容规则
* 派生类对象可以赋值给基类对象
* 派生类对象可以初始化基类引用
* 派生类对象的地址可以赋值给基类指针

## struct 和 class 区别
* 为了实现链式表达式

## 野指针（指向不可用内存区域的指针）。
* 野指针不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是野指针是很危险的，也具有很强的掩蔽性，if语句对它不起作用。
* 造成野指针的常见原因有三种：
	* 1、**指针变量没有被初始化**。任何指针变量刚被创建时不会自动成为NULL指针。在Debug模式下，VC++编译器会把未初始化的栈内存上的指针全部填成 0xcccccccc ，当字符串看就是 “烫烫烫烫……”；会把未初始化的堆内存上的指针全部填成 0xcdcdcdcd，当字符串看就是 “屯屯屯屯……”。把未初始化的指针自动初始化为0xcccccccc或0xcdcdcdcd，而不是就让取随机值，那是为了方便我们调试程序，使我们能够一眼就能确定我们使用了未初始化的野指针。在Release模式下，编译器则会将指针赋随机值，它会乱指一气。所以，指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。
	*  2、**指针指向的内存被释放了，而指针本身没有置NULL**。对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符）。指针指向的内存被释放了，而指针本身没有置NULL。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用。因为即便p不是NULL指针，它也不指向合法的内存块。所以在指针指向的内存被释放后，应该将指针置为NULL。
	*  3 、**指针超过了变量的作用范围**。即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来引起的。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量

## stl 相关容器，底层用什么实现的？

* 1. `vector`是我们用到最多的数据结构，其底层数据结构是数组，由于数组的特点，`vector`也具有以下特性：
	* 1、O(1)时间的快速访问；
	* 2、顺序存储，所以插入到非尾结点位置所需时间复杂度为O(n)，删除也一样；
	* 3、扩容规则：当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如`std::vector<int> vec`，当通过`push_bac`k向其中增加元素时，如果初始分配空间已满，就会引起`vector`扩容，其扩容规则在gcc下以2倍方式完成：首先重新申请一个2倍大的内存空间；然后将原空间的内容拷贝过来；最后将原空间内容进行释放，将内存交还给操作系统；
	* 在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。

* `map`与`multimap`是STL中的关联容器、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。这两个关联容器的底层数据结构均为**红黑树**，map与multimap可以实现`O(lgn)`的查找，插入和删除。

* `unordered_map`与`unordered_multimap` 对比2.1中的两种map在于其2.1中的两个容器实现了以key为序排列，也就是说map与multimap为有序的。而unordered_map与unordered_multimap中key为无序排列，其底层实现为`hash table`，因此其查找时间复杂度理论上达到了`O(n)`，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。

* `set` & `multiset` & `unordered_set` & `unordered_multiset`: 以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是`<key-value>`，而set可以理解为关键字即值，即只保存关键字的容器。
	* `set`与`multiset`有序存储元素，这两种容器的底层实现与map一样都是红黑树，所以能实现O(lgn)的查找，插入，删除操作。set与multiset的区别在于是否允许重复；
	* unordered_set & unordered_multiset,与unordered_map & unordered_multimap相同，其底层实现为hash table；

* `priority_queue`优先级队列相当于一个**有权值**的单向队列queue，在这个队列中，所有元素是按照优先级排列的。priority_queue根据**堆**的处理规则来调整元素之间的位置，根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为O(1),对于插入和删除，其最坏情况为O(lgn)。

* list的底层数据结构为双向链表，特点是支持快速的增删。
* queue为单向队列，为先入先出原则。
* deque为双向队列，其对比queue可以实现在头尾两端高效的插入和删除操作。



## 1亿个数取前k大的数
先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。
优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。

## 堆排序，快速排序的原理与时间复杂度
O(nlog2n)
“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。

## 一次可以跳一个或者两个楼梯，跳到第n 层的走法有多少种？
n层台阶可以是这么够成的
1.第n层台阶是从第n-1层跳1级上来的
2.第n层台阶是从第n-2层直接跳2级上来的
所以可以得到n层的跳法总数是F(n)=F(n-1)+F(n-2)

## 一次可以跳任意个楼梯，跳到第n 层的走法有多少种？
2^n

##八皇后问题

##A*算法

## 平衡树，红黑树，B-树，B+树
* AVL平衡二叉搜索树
	* 定义：平衡二叉树或为空树,或为如下性质的二叉排序树:
		* （1）左右子树深度之差的绝对值不超过1;
		* （2）左右子树仍然为平衡二叉树.
	* 平衡因子BF=左子树深度－右子树深度.平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。

* RBT 红黑树    
	* AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；
红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；
所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。

	* 红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。
	* 一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：
		* 1）每个结点要么是红的，要么是黑的。
		* 2）根结点是黑的。
		* 3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
		* 4）如果一个结点是红的，那么它的俩个儿子都是黑的。
		* 5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
* B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
	* 1.定义任意非叶子结点最多只有M个儿子；且M>2；
	* 2.根结点的儿子数为[2, M]；
	* 3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
	* 4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

       5.非叶子结点的关键字个数=指向儿子的指针个数-1；
* B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；更适合文件索引系统

